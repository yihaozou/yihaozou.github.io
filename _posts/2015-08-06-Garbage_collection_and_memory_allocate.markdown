---
author: 邹政华
comments: true
date: 2015-08-06
published: true 
tags: Java
layout: post
title:  深入理解Java虚拟机－垃圾收集与内存分配
categories: 读书 
---

###引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

引用技术算法的实现简单，判定效率也很高，大部分情况下它都是一个不错的算法。但是主流的Java虚拟机里面并没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

###可达性分析算法

通过一系列成为“GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：
* 虚拟机栈(栈帧中的本地变量表)中引用的对象；
* 方法区中类静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方法栈中JNI(即一般说的Native方法)引用的对象。


### 引用

对于一些“食之无味，弃之可惜”的对象，当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。

* 强引用就是指在程序代码之中普遍存在的，类似“Object obj＝new Object()”这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

* 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

* 弱引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对起生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 回收方法区

判断一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多，类需要同时满足下面三个条件才能算是“无用的类”：

* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；

* 加载该类的ClassLoader已经被回收;

* 该类对应的java.lang.Class对象没有在任何对方被引用，无法在任何地方通过反射访问该类的方法。


###垃圾收集算法之标记－清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不足之处在于：一是效率问题，标记和清除两个过程的效率都不高；二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

###垃圾收集算法之复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。代价是将内存缩小为原来的一半。

也可以将内存划分为一块较大的Eden空间和两块较少的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。


###垃圾收集算法之标记－整理算法

标记过程仍然与“标记－清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

###垃圾收集算法之分代收集算法

根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必需使用“标记－清理”或者“标记－整理”算法来进行回收。

##内存分配与回收策略

对象的分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机与内存相关的参数的设置。

大对象（比如很长的字符串或者数组）对虚拟机的内存分配来说是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”他们。

###动态对象年龄判定

为了能更好地适应不同程序地内存状况，虚拟机并不是永远地要求对象地年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小地总和大于Survivor空间地一半，年龄大于或等于该年龄地对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求地年龄。
