---
author: 邹政华
comments: true
date: 2015-3-10
published: false 
tags: Java
layout: post
title:  Java并发编程实践－线程安全性
categories: 读书 
---

一个线程是否需要是线程安全的，取决于它是否被多个线程访问。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。访问某个变量的代码越少，就越容易确保对变量的所有访问能实现正确同步，程序状态的封装性约好，就越容易实现程序的线程安全性。


有时候，面向对象中的抽象和封装会降低程序的性能，但在编写并发应用程序时，一种正确的编程方法是，首先使程序正确运行，然后再提高代码的速度。即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化再实际环境中确实能带来性能提升时，才进行优化。


无状态对象一定是线程安全的：无状态指的是既不包含任何域，也不包含任何对其他类中域的引用。



当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件，从而使结果变得不可靠。大多数竞态条件的本质，基于一种可能失效的观察结果来做出判断或者执行某个计算。这种类型的竞态条件称为“先检查后执行”，首先观察某个条件为真，然后根据这个观察结果采用相应的动作，但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效，从而导致各种问题。



要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。



重入：当线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。但是某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。



并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。



对在单个变量上实现原子操作来说，原子变量很有用，但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处。



在简单性和性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性，这可能会破坏安全性。



当执行时间较长的计算或者可能无法快速完成的操作时（例如网络I/O或者控制台I/O），一定不要持有锁。







