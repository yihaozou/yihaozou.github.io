<p>一个朋友工作中遇到的问题：已知一个任意的自然数T，和一个大于1小于T的自然数L。求小于L的自然数R1，R2，R3…Rn, n个数不限但越小越好，使得R1xR2xR3…xRn大于等于T并最接近于T。同时有多个解取任意解。</p>

<p>我想到的一种方法是全排列，即将所有可能的组合全部尝试一遍。目标组合的乘积R与T的差最小（前提是R&gt;=T),并且目标组合的元素个数最少（在差一样的情况下）。但是这样会碰到两个问题：</p>

<ol>
  <li>
    <p>全排列的组合数目太大，对于数组{1,2…N},全排列的数量将是N！，在用递归来解决的时候，对机器性能要求过高（在n很大的情况下）。</p>
  </li>
  <li>
    <p>在n较大的情况下，乘法运算容易导致溢出。而32位整数能够表示的最大自然数为0X7FFFFFFF.</p>
  </li>
</ol>

<p>所以对排列进行筛选十分必要，在已有的条件下如果能够判断出候选组合不能满足条件，就没有必要继续递归了。比方说，目标组合有10个元素，但是其中4个元素的乘积与T的差已经大于当前最优方案了，那么就没有必要再计算所有10个元素的乘积了,目标组合被排除。这样可以节约时间并且防止溢出。</p>

<p>解决方案是用c语言实现的，代码托管在https://github.com/yihaozou/select_permutaion</p>

