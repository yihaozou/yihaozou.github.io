---
author: 邹政华
comments: false
published: false
date: 2015-06-23
layout: post
slug: '10'
tags: 分布式系统
title: 分布式一致性－PAXOS算法
categories: 读书
---

在分布式系统中，每一个机器节点虽然读能够明确地知道自己在进行事物操作过程中的结果是成功还是失败，但却无法直接获取到其他分布式节点的操作结果。因此，当一个事物操作需要跨越多个分布式节点的时候，为了保持事物处理的ACID特性，就需要映入一个称为"协调者"(Coordinator)的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为"参与者"(Participant)。

假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：

* 在这些被提出的提案中，只有一个会被选定
* 如果没有提案被提出，那么就不会有被选定的提案
* 当一个提案被选定后，进程应该可以获取被选定的提案信息

对于一致性来说，安全性(sagety)需求如下：

* 只有被提出的提案才能被选定(chosen)
* 只能有一个值被选定
* 如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个

从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，进程最终也能获取到被选定的提案。

在Paxos算法中，有三种参与角色，我们用Proposer,Acceptor和Learner来表示。在具体实现中，一个进程可能充当不止一种角色，在这里我们并不关心进程如何映射到各种角色。假设不同参与者之间可以通过收发消息来进行通信，那么：

* 每个参与者以任意速度执行，可能会因为出错而停止，也可能重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。

* 消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改

###提案的选定

可以使用多个Acceptor来避免Acceptor的单点问题。在存在多个Acceptor的情况下，Proposer向一个Acceptor集合发送提案，集合中的每个Acceptor都可能会批准(Accept)该提案，当有足够多的Acceptor批准这个提案的时候，我们就可以认为该提案被选定了。什么是足够多呢？我们假定足够多的Acceptor是整个Acceptor集合的一个子集，并且让这个集合大得可以包含Acceptor集合中的大多数成员，因为任意两个包含大多数Acceptor的自己至少有一个公共成员。另外我们再规定，每一个Acceptor最多只能批准一个提案，那么就能保证只有一个提案被选定了。

###算法陈述

阶段一：

1. Proposer选择一个提案编号M，然后向Accpter的某个超过半数的子集成员发送编号为M的Prepara请求

2. 如果一个Acceptor收到一个编号为M的prepare请求，且编号M大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M的提案。举个例子，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1,2,...5和7，那么该Acceptor在接收到一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer

阶段二：
1. 如果Proposer收到半数以上的Acceptor对于其发出的编号为M的prepare请求的响应那么他就会发送一个针对［M, V]提案的Accept请求给Acceptor。注意，V的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。

2. 如果Acceptor收到这个针对[M，V]提案的Accept请求，只要该Acceptor尚未对编号大于M的Prepare请求做出响应，它就可以通过这个提案。

###提案的获取

方案一：

Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor皮春，因此最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner。

这种做法需要每个Acceptor和所有的Learner逐个进行一次通信，通信次数至少为二者个数的乘积

方案二：

让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定Learner（称为“主Learner”），在不考虑拜占庭将军问题的前提下我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的Learner。

这种做法的风险在于：主Learner随时可能出现鼓掌。

方案三：

针对方案二的单点问题，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Leaner集合的元素个数越多，可靠性就约好，但同时网络通信的复杂度也就越高。


###通过选取主proposer保证算法的活性

可能会存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定。解决这个问题可以选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。



