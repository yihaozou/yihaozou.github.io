---
author: 邹政华
comments: true
published: false
date: 2014-07-08 04:21:48+00:00
layout: post
slug: '%e5%85%a8%e6%8e%92%e5%88%97%ef%bc%8c%e9%80%92%e5%bd%92%e5%8f%8a%e7%ad%9b%e9%80%89'
title: 全排列，递归及筛选
wordpress_id: 454
categories: 编程
---

一个朋友工作中遇到的问题：已知一个任意的自然数T，和一个大于1小于T的自然数L。求小于L的自然数R1，R2，R3...Rn, n个数不限但越小越好，使得R1xR2xR3...xRn大于等于T并最接近于T。同时有多个解取任意解。

我想到的一种方法是全排列，即将所有可能的组合全部尝试一遍。目标组合的乘积R与T的差最小（前提是R>=T),并且目标组合的元素个数最少（在差一样的情况下）。但是这样会碰到两个问题：

1. 全排列的组合数目太大，对于数组{1,2...N},全排列的数量将是N！，在用递归来解决的时候，对机器性能要求过高（在n很大的情况下）。

2. 在n较大的情况下，乘法运算容易导致溢出。而32位整数能够表示的最大自然数为0X7FFFFFFF.

所以对排列进行筛选十分必要，在已有的条件下如果能够判断出候选组合不能满足条件，就没有必要继续递归了。比方说，目标组合有10个元素，但是其中4个元素的乘积与T的差已经大于当前最优方案了，那么就没有必要再计算所有10个元素的乘积了,目标组合被排除。这样可以节约时间并且防止溢出。

解决方案是用c语言实现的，代码托管在https://github.com/yihaozou/select_permutaion


