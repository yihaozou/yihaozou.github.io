<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">

<title>学习笔记</title>
<meta name="description" content="Read Think Create.">
<meta name="keywords" content="zhenghua, 邹政华, meiyueyibenshu, zou zhenghua">

<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/main.css">
<link rel="canonical" href="http://zhenghua.info/page4/">
<link rel="alternate" type="application/atom+xml" title="学习笔记" href="http://zhenghua.info/zfeed.xml" />

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});

$(document).ready(function(){
  $(".flip").click(
      function(){
        $(".panel").toggle(500);
      });
});
</script>


</head>


<body>

<div class="container">

  <header class="site-header">

  <div class="wrapper">

    <h1 class="site-title"><a href="/">学习笔记</a></h1>
    <h3 class="site-meta">slow is fast.</h3>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
        <a class="page-link" href="/">主页</a>
        
        
        
        <a class="page-link" href="/about/">关于我</a>
        
        
        
        <a class="page-link" href="/archives/">写作记录</a>
        
        
        
        <a class="page-link" href="/categories/">文章分类</a>
        
        
        
        <a class="page-link" href="/guestbook/">留言簿</a>
        
        
        
        
        
        
        
        <a class="page-link" href="/tags/">标签</a>
        
        
        
        <a class="page-link" href="/zfeed.xml">订阅我</a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </div>
    </nav>

  </div>

</header>


    

  <div class="page-content col-sm-8">
    <div class="home">
  <div class="post">
    
    
  
    <header class="post-header">
      <h1 class="post-title">
        <a class="post-link" href="/%E8%AF%BB%E4%B9%A6/2015/08/05/Java_memory_model.html">深入理解Java虚拟机－Java内存区域</a>
      </h1>
      <p class="post-meta">
      目录:
      
      <a href="/categories/#读书">读书</a>&nbsp;
      
      
      | 标签:
      
      <a href="/tags/#Java" title="Java">Java </a>
      
      
      | 发表时间: Aug 5, 2015
      </p>
    </header>

    <article class="post-content">
      <p>程序计数器：Java虚拟机的多线程时通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响。</p>

<p>Java虚拟机栈：在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常：如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>

<p>本地方法栈：功能与虚拟机栈类似，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>

<p>Java堆：对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。</p>

<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC”堆。</p>

<p>Java堆可以在物理上不连续的内存空间中，只要逻辑上是连续的即可。</p>

<p>方法区：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>

<p>垃圾收集行为在这个区域是比较少出现的。</p>

<p>运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>

<p>Java虚拟机对Class文件每一部分(包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。</p>

<p>直接内存：直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>

<p>在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)中的I/O方式，它可以使用Native函数哭直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>

<p>对象的创建(HotSpot虚拟机)：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>

<p>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>

<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例</p>

<p>对象的内存布局：在HotSpot虚拟机中，对象在内存中存储的布局可以氛围3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding).</p>


    </article> <hr />
    
    
  
    <header class="post-header">
      <h1 class="post-title">
        <a class="post-link" href="/%E8%AF%BB%E4%B9%A6/2015/07/30/too_big_too_know.html">知识的边界</a>
      </h1>
      <p class="post-meta">
      目录:
      
      <a href="/categories/#读书">读书</a>&nbsp;
      
      
      | 发表时间: Jul 30, 2015
      </p>
    </header>

    <article class="post-content">
      <p>我还在学校念书的时候，参与过译言网的一个协作翻译项目。项目组织者将外文书按章节划分，每个志愿者负责一部分，然后交由项目负责人评审。经过评审、修改、反馈，迭代数个周期后，  译稿最终付梓出版。</p>

<p>项目发起之初衷，是希望将尽可能多的优秀外文书籍，以最快的速度推向中文读者。现如今书籍的出版速度越来越快，每年有无数外文书籍出版，传统的引进方式，已然无法满足需求。</p>

<p>这种协作方式的缺点在于无法保证翻译质量。因为参与项目的志愿者大多抱有提升英文水平的想法，自身翻译水平有限；另一方面，多个志愿者的翻译风格也很难保持统一。所以在选择翻译标的的时候，以快餐文学和名人回忆录居多。</p>

<p>在我的父辈们看来，书籍是值得严肃对待的物品，写书出版更是一件很神圣的事情。或者在古代的中国，纸张昂贵，识字率低，没有公立学校，书籍往往是留给子孙最有价值的财产。彼时彼刻，书籍既是知识的承载者，同时也是权力的阶梯。说“书中自有黄金屋”，一点也不过分。</p>

<p>到了今天，情况发生了很大的变化。</p>

<p>出版书籍变成了商业行为，门槛降低，很多非专业的公众人物也开始出版自传或者随笔，因为这在商业上有利可图。我并非在否定这类出版行为的意义，只是意在说明，现如今纸质媒介正在以一种极高的速率膨胀。而且随着时间世代延续，书籍的数量会一直增加。所以，人们可以料想，这样一个时刻终会来临，届时人们从书中学习东西，都像是从浩瀚的宇宙中直接学习一样困难。</p>

<p>不仅仅是书籍，互联网的出现也使得信息以极快的速度膨胀。如今人们一次google获取的信息也许比一座小型图书馆包含的信息还多。这是一个信息过载的时代。</p>

<p>作为应对措施，人们发明了各种各样的过滤机制。</p>

<p>传统上，公立学校会有一套教材清单，这是一套过滤机制，决定了学生们在学校会学习到什么内容；图书馆的采编委员会起到了类似的作用，决定了我们在图书馆会看到什么书籍，这些书数量有限，相对于每年出版的所有书籍来说，仅是沧海一粟。在互联网时代，新的过滤机制不再仅仅以内容为维度进行区分。比方说google等搜索引擎依靠算法来保证信息的质量，而这些算法依赖的指标除内容外，还增加了点击数和链接数目等。微信朋友圈的过滤机制依赖于用户的社交网络；而在程序员和学生中广受欢迎的知乎，大V们在很大程度上扮演了过滤器的作用。</p>

<p>获取知识的新方式正日益明朗，虽然我们还不能确切知道它的成熟态，但某些方面已经慢慢成型。网络化的知识不是那么令人信赖，但却更加全面包容；不是那么一以贯之却更加丰富多元。</p>

<p>在《知识的边界》里，作者遵循一种“独特的路径”（每个章节探讨特定的主题，然后连成一线）来探讨这个大到不可知的领域。所谓大到不可知，是指知识的范畴广阔到我们不可能了解全部。</p>

<p>一、云上的专家</p>

<p>互联网首要的也是最明显的一个特点就是它造就了有史以来最大的群体。这种规模上的巨大性也造就了新的可能性，一群本不相关的人共同解决问题，或者为那些大到任何专家个人都无法解决的议题提供知识资源。利用“网络化的知识”，问题的响应速度越来越快。当有足够多的人参与的时候，足够的宽度本身就成为了一种深度。</p>

<p>『2007年，美国溢油防治技术研究所提供两万美元奖金，奖励第一位能将沉在阿拉斯加海底18年的溢油抽出来的人。直接把石油抽出来没用，因为当它到达海面时，冰冷的阿拉斯加空气会让石油和水的混合物凝固。一位住在伊利诺伊州的化学家，虽然不太懂石油，但他非常懂水泥，只要一直震动，水泥就不会凝固。应用这种思路，问题最终得到解决』</p>

<p>在网络时代，“房间里最聪明的人不是站在讲台前给我们讲课的人，也不是房间里所有人的集体智慧。房间里最聪明的人就是房间本身：房间联接人们和思想并连接外部的网络。”就像生命并非活在我们的神经、骨骼、血液、骨髓之中，而活在这一切所构成的联系之中。网络化的知识，会让我们更加接近关于知识的真理。</p>

<p>二、互联网让我们变笨了？</p>

<p>每个人都可以有他自己的观点，但不可以有他自己的事实。”（Everyone is entitled to his own opinions，but not to his own facts.）</p>

<p>纸张的局限让事实看上去比现在更易控制，因为现在我们眼见着事实被链接进了不受限制的网络中。一方面，我们希望能有更多意外发现带来的惊喜（serendipity），如此一来，人们便不会被束缚在他们的舒适区。另一方面，几乎所有的人都在抱怨互联网太分散人们的注意力，充斥了过多的意外。可利用信息数量的大幅增加反而让我们比以往更容易犯错。我们可以随手获得如此多的事实，以至于失去了得出结论的能力，因为总是有其他事实支持其他的说法。</p>

<p>互联网本身包含丰富的多样性，存在太多的分歧。没有一个突出的占据优势地位的观点，我们将会迷失在一个不同观点织就的漩涡里。我们需要人们对任何事都无法达成共识且将来也无法达成共识的世界里探索如何获得知识。</p>

<p>我们之所以又这些矛盾，是因为网络上观点杂乱，迫使我们去面对知识策略中的那种张力，而这种张力此前被旧式的知识媒介所掩盖。我们原以为知识会在一个生机勃勃的“观念市场”中繁荣增长，因为以纸张为载体的知识将绝大部分的竞争性观念排除在我们的本地市场之外。现在我们看到自己身边的各种观念是如此地多元和互异－－因为总的来说，互联网过滤器并不会真的删掉东西，而只是把受青睐的材料拿得更近一些－－我们对这种新的多样性得价值感到极度困惑。</p>

<p>三、知识的新结构</p>

<p>丰富性，对知识得寻觅者而言，现在知识的基础设施以及搜索工具，让我们能够基础到比以往任何时候都多得作品。数字化令寻找信息变得便利。只要轻轻一点，就可以在马尔萨斯作品的第六版和第一版之间转换，然后发现第一版完全缺少数据支撑－如果在当地的图书馆里，这简直是一项不可能完成的任务。新技术极大地改进了研究者的能力，他们可以从容不迫地寻找资料，或者深入地挖掘信息。</p>

<p>链接。现代出版的学术作品，几乎处处都是脚注，部分是为了验证观点，但更多的为了避免侵犯这个疯狂时代中别人对观点的微观所有权。链接改变了知识基本的拓扑结构，发展出的观点的每一个小片段，都存在于一个相互关联的、没有阻隔的网络中，我们知道的每一个主题都不限于它所讲述的内容，因为我们会看到那些链接，一天之内就可以访问上千个相关网页。</p>

<p>无需许可。传统上知识像是一个俱乐部，它接纳新成员，一本书、一篇论文、一种观点都必须在经过了有资质的专家团体的检查之后才成为可能。如果任何人都能随意出版任何东西，任何人收集几个链接就可以管理资料库，那么知识俱乐部就失去了价值。知识的排他性已经渐渐丧失。</p>

<p>公共性。曾经，我们认为不让普通人接触到重要知识是为了他们好。很长一段时间，我们只教给儿童足够去天地或者工厂干活的知识。而现在，我们给公众的，不仅仅时教育、图书馆，还有一种通道、一键点击即可接触到近乎无限的知识和文化作品。</p>

<p>四. 有效地利用知识</p>

<p>开放通道。纸张特性需要出版商审慎选择印刷内容是一回事，而出版商将自己的作品定价过高以至于只有精英才能读得起是另一回事。当学术期刊收取每年2万美元的订阅费时，它们已经变成了获取知识的障碍，而非动力。于是开放取用运动的成功几乎是不可避免的，因为无论是从经济上还是社会趋势上都注定了如此。</p>

<p>萃取优质信息。丰富性也存在两个主要的风险，首先，我们找不到需要的东西；其次，我们会找到很多迎合我们最低需求的有吸引力的东西。解决信息超载的方法是创造更多的信息：元数据。网络上大部分东西都是垃圾。所以我们需要找到方法去评估它们。有些这样的元数据的增多需要人们付出更加明显的努力：我们积累数据的集合，给它们打分、留言、写评论，或者像亚马逊一样用算法来实现。</p>

<p>链接一切。链接可以将作品置于上下文之中，促使我们去学习更多的东西。一个从慢思想的网络，让我们得以一窥纸张的背后，也得以跟随自己的兴趣在网络的边疆自由穿行，它也构成了一个聪明的模式。</p>

<p>不要把制度化知识留在身后。传统机构的力量所在（提供知识的资质），同时也是他们的弱点所在。他们将所有的知识者聚在一起，但是没有几个申请人能够进入。机构隔绝了外界，同样也孤立了思想。即使我们称它们形成了“思想流派”，其实机构更像回声室。网络不会摧毁所有的机构，相反机构正在更加深入地嵌入到网络中。而且网络也发展出了自己的机构，拥有和传统机构同样的弱点。如果网络想成为知识的新的基础设施，那么它就必须利用好所有现存的机构发展出来的知识。</p>

<p>学会热爱不同。当我们限制自己、不允许自己的舒适受到一丁点打扰的时候，就是我们变蠢的时候。如果希望网络容纳知识的能力最大化，我们就需要超越内心的惰性：和像我们一样的人黏在一起。</p>

<p>五. 下一个达尔文是数据狂人？</p>

<p>达尔文在思想史上迈出了任何人都没有预测到的一大步。这一步，是数年辛勤工作和数千盈利的周游后得到的。</p>

<p>但是从另一个角度解读，达尔文的观点也是从一个丰富的网络中发展出来的，如果没有拉玛克的工作，达尔文可能根本不会想到进化论。如果没有查尔斯.莱尔的《地质学原理》，那他可能也根本不会有生命在漫长的时间内逐步演化的想法。达尔文所处的网络是由同事和书信往来的人组成。</p>

<p>下一个达尔文，他的工作很可能是公开进行的，也就是说，是在一个相互链接的网上进行的。他可能不会等到有最终结论才发表，而是会在网上贴出自己的早期成果，然后他的文字一发表，一个链接之网就在他周围生成。某些节点会变成中心。最终这个网络中会产生出新的观点并将观点传播出去。</p>

    </article> <hr />
    
    
  
    <header class="post-header">
      <h1 class="post-title">
        <a class="post-link" href="/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%81%90%E6%83%B3/2015/07/24/some_thoughs_when_work_for_two_years.html">遐想四-毕业两周年</a>
      </h1>
      <p class="post-meta">
      目录:
      
      <a href="/categories/#总结与遐想">总结与遐想</a>&nbsp;
      
      
      | 发表时间: Jul 24, 2015
      </p>
    </header>

    <article class="post-content">
      <p>1.毕业之后，时间过得越来越快，年初还有很多美好的想法,期待着发生很多事情，转眼到了年中，结果什么事情也没有发生，莫名就觉得很惆怅。</p>

<p>2.硕士研究生三年制太长了，设置为一年比较合适。不然等到毕业,青春消逝殆尽,无论干什么事都多了一层焦虑感。而且，和导师相处得时间过长，人性猥琐的一面充分暴露出来,最后大家相互嫌弃,所谓师道尊严就成了笑话。</p>

<p>3.以前在实验室，导师放养的话，学生找的工作都还不错；导师要求严格，学生找到的工作相对要逊一些。有些师弟因为没有找到理想的工作而烦恼, 大可不必,以后的路还长着呢。</p>

<p>4.保罗.格雷厄姆在自己的博客中提到，即便再最高新的技术企业里，也有90%的工作内容是重复或无聊的。重复和繁重的工作会磨灭人的理想和激情，解决方案是尽早发现的兴趣所在或者争取实现财务自由。</p>

<p>5.说到挣钱，分享一个很有意思的观点。如果把人一生赚的钱分成两部分，四十岁以前和四十以后，那么前者只占总体的很少一部分。所以在面临人生重大决定时，不妨将目光放长远些。</p>

<p>6.毕业后去了农行，一家典型的巨无霸国企。我能够理解老一辈的人为什么会推崇国企，国企更容易给人安全感。一直到现在，农行软开新进员工的整体素质还是优于一些主流的互联企业。</p>

<p>7.以前在某基金公司实习，总经理在总结选股得失的时候，喜欢强调“痛苦的思索，深刻的反省”。我当时太年轻，不能理解这种强力的词汇.但是经历过人生的一些起落后发现，有时候真的很难用语言来形容当时当地的喜悦或懊恼。</p>

<p>8.不要过于在乎别人的想法，尤其是兴趣和志向不同的人；不要试图成为一个好人，要成为一个强大的人；人这一生还是要做成一件事情，不然白活了。</p>

    </article> <hr />
    
    
  
    <header class="post-header">
      <h1 class="post-title">
        <a class="post-link" href="/%E8%AF%BB%E4%B9%A6/2015/06/23/from_paxos_to_zookeeper.html">分布式一致性－PAXOS算法</a>
      </h1>
      <p class="post-meta">
      目录:
      
      <a href="/categories/#读书">读书</a>&nbsp;
      
      
      | 标签:
      
      <a href="/tags/#分布式系统" title="分布式系统">分布式系统 </a>
      
      
      | 发表时间: Jun 23, 2015
      </p>
    </header>

    <article class="post-content">
      <p>在分布式系统中，每一个机器节点虽然读能够明确地知道自己在进行事物操作过程中的结果是成功还是失败，但却无法直接获取到其他分布式节点的操作结果。因此，当一个事物操作需要跨越多个分布式节点的时候，为了保持事物处理的ACID特性，就需要映入一个称为”协调者”(Coordinator)的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为”参与者”(Participant)。</p>

<p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：</p>

<ul>
  <li>在这些被提出的提案中，只有一个会被选定</li>
  <li>如果没有提案被提出，那么就不会有被选定的提案</li>
  <li>当一个提案被选定后，进程应该可以获取被选定的提案信息</li>
</ul>

<p>对于一致性来说，安全性(sagety)需求如下：</p>

<ul>
  <li>只有被提出的提案才能被选定(chosen)</li>
  <li>只能有一个值被选定</li>
  <li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个</li>
</ul>

<p>从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，进程最终也能获取到被选定的提案。</p>

<p>在Paxos算法中，有三种参与角色，我们用Proposer,Acceptor和Learner来表示。在具体实现中，一个进程可能充当不止一种角色，在这里我们并不关心进程如何映射到各种角色。假设不同参与者之间可以通过收发消息来进行通信，那么：</p>

<ul>
  <li>
    <p>每个参与者以任意速度执行，可能会因为出错而停止，也可能重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。</p>
  </li>
  <li>
    <p>消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改</p>
  </li>
</ul>

<h3 id="section">提案的选定</h3>

<p>可以使用多个Acceptor来避免Acceptor的单点问题。在存在多个Acceptor的情况下，Proposer向一个Acceptor集合发送提案，集合中的每个Acceptor都可能会批准(Accept)该提案，当有足够多的Acceptor批准这个提案的时候，我们就可以认为该提案被选定了。什么是足够多呢？我们假定足够多的Acceptor是整个Acceptor集合的一个子集，并且让这个集合大得可以包含Acceptor集合中的大多数成员，因为任意两个包含大多数Acceptor的自己至少有一个公共成员。另外我们再规定，每一个Acceptor最多只能批准一个提案，那么就能保证只有一个提案被选定了。</p>

<h3 id="section-1">算法陈述</h3>

<p>阶段一：</p>

<ol>
  <li>
    <p>Proposer选择一个提案编号M，然后向Accpter的某个超过半数的子集成员发送编号为M的Prepara请求</p>
  </li>
  <li>
    <p>如果一个Acceptor收到一个编号为M的prepare请求，且编号M大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M的提案。举个例子，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1,2,…5和7，那么该Acceptor在接收到一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer</p>
  </li>
</ol>

<p>阶段二：
1. 如果Proposer收到半数以上的Acceptor对于其发出的编号为M的prepare请求的响应那么他就会发送一个针对［M, V]提案的Accept请求给Acceptor。注意，V的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</p>

<ol>
  <li>如果Acceptor收到这个针对[M，V]提案的Accept请求，只要该Acceptor尚未对编号大于M的Prepare请求做出响应，它就可以通过这个提案。</li>
</ol>

<h3 id="section-2">提案的获取</h3>

<p>方案一：</p>

<p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor皮春，因此最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner。</p>

<p>这种做法需要每个Acceptor和所有的Learner逐个进行一次通信，通信次数至少为二者个数的乘积</p>

<p>方案二：</p>

<p>让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定Learner（称为“主Learner”），在不考虑拜占庭将军问题的前提下我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的Learner。</p>

<p>这种做法的风险在于：主Learner随时可能出现鼓掌。</p>

<p>方案三：</p>

<p>针对方案二的单点问题，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Leaner集合的元素个数越多，可靠性就约好，但同时网络通信的复杂度也就越高。</p>

<h3 id="proposer">通过选取主proposer保证算法的活性</h3>

<p>可能会存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定。解决这个问题可以选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。</p>


    </article> <hr />
    
    
  
    <header class="post-header">
      <h1 class="post-title">
        <a class="post-link" href="/%E8%AF%BB%E4%B9%A6/2015/06/12/the_cathedral_and_the_bazaar.html">大教堂与集市</a>
      </h1>
      <p class="post-meta">
      目录:
      
      <a href="/categories/#读书">读书</a>&nbsp;
      
      
      | 发表时间: Jun 12, 2015
      </p>
    </header>

    <article class="post-content">
      <p>一</p>

<p>在quora上看到的问题「为什么会有人无偿创建像维基百科这样的网站?」，吉米.威尔士本人的回答是，「因为这棒极了（awesome)」。我认为这个回答较好地体现了黑客精神，因此特意摘录了下来。</p>

<p>二</p>

<p>那么究竟什么是黑客精神呢？</p>

<p>长期以来，存在一个崇尚高尚文化且成员都是编程专家和网络高手的社区（早期网络和主机普及度不高，所以用户大多来自学术圈或大公司实验室），这个社区的成员创造了黑客一词，黑客构建了互联网、UNIX操作系统、Usenet以及广泛应用的万维网WWW。</p>

<p>这个世界充满了各种各样迷人的问题，黑客的使命是去解决这些问题。成为一名黑客意味着对解决问题、磨砺技能和智力挑战有着基本的兴奋感。</p>

<p>黑客精神并不局限于软件文化中。人们会把黑客态度用在其他事情上，比如电子或音乐。对任何科学和艺术，在其最高水平的活动中都可以发现这种精神。</p>

<p>三</p>

<p>要向外行解释软件开发这个行当，可以用建筑业来进行类比，开发一个软件就像盖一栋房子。</p>

<p>若要盖一个教堂，需要事先进行设计，收集原材料，然后将优秀的工匠集中在一起，这些人经过几个月或几年与外界相对隔绝的工作状态后最终产生了成果。大教堂的特点是封闭式建设、成本高、品质优异。传统的软件开发理念大多是基于这一模式。</p>

<p>与大教堂相对应的是集市。集市的特点是开放式建设、成本低、品质平庸，但是如果将软件开发置于透明和民主的氛围中，更好的完善其开发过程，也同样能够减少最终Bug的产生。</p>

<p>绝大多数商业公司采用了“大教堂”模式，而以Linux为代表的开源软件采用的是“集市”模式，两者根本不同点在于他们对软件排错有着完全对立的认识。从Linux的经验出发，证实了这样一个命题“只要眼睛多，bug容易捉”，这和那些由利己主义个体组成的自纠错系统有着异曲同工之妙。</p>

<p>互联网的普及，使得黑客之间有了广泛的交流与合作，他们编些软件时所采用的便是集市模式。黑客们卓越的天赋和工作成果产生了广泛的影响，引发了后来轰轰烈烈的开源运动。</p>

<p>现如今广泛使用的Linux、Apache、Nginx、Mysql等都是开源软件。</p>

<p>四</p>

<p>黑客们参与开源运动的热情可以归结为“礼物文化”。</p>

<p>“礼物文化”指的是，参与者付出时间、精力和创意，去竞争获取声望的文化。这类似于法律和政治学里关于土地所有制的习惯法理论，如果边缘地区有一块土地，人们可以通过开垦、耕种、守护来获取土地所有权，与之相对应的是，黑客们通过贡献和维护代码来体现在项目中的地位。</p>

<p>自由市场经济是全世界范围内通过合作获得经济效能的最佳方法，这一点看来已成为历史定论，同样，基于声誉竞争的礼物文化可能是通过合作产生（和检验）高质量创造性工作的最佳方法。</p>

<p>五</p>

<p>开源是一种手段，而不是目的。</p>

<p>我们总能在宗教和政治领域看到各种各样的原教旨主义者。在软件开发领域也同样如此，比方说Richard Stallman坚持认为贩卖不附带源代码的二进制软件是十分不道德的。这种指责虽然尖刻，但并不能给竞争对手带来实质性的损害。</p>

<p>软件开发附属于商业行为基础之上，否定这个基础并不是理性务实的做法。只有证明自己的商业潜力，开源运动才能获得主流媒体和华尔街的认同，进一步的发展和扩张才有可能持续。</p>


    </article> <hr />
    
    
  
  </div>
</div>

    <section class="pager">
  
  
  <li class="previous"><a href="/page3/" title="后一页">&larr; 后一页</a></li>
  
  
  
  <li class="next"><a href="/page5/" title="前一页">前一页 &rarr;</a></li>
  
</section>


  </div>
  <div class="col-sm-2">
<div class="sidebar-module about">
  <h4>关于我</h4>
  <img title="Lijia YU" src="https://i.imgur.com/Mdc4szJl.jpg" alt="Lijia YU"/>
  <span>Hi,我是邹政华，欢迎访问我的博客。</span>
  <br />

  



  

</div>

<div class="sidebar-module">
  <h4>近期文章</h4>
  
  <li>
  <a href="/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%81%90%E6%83%B3/2017/12/17/thoughts5.html" title="遐想(五)" rel="bookmark">遐想(五)</a>
  </li>
  
  <li>
  <a href="/%E8%AF%BB%E4%B9%A6/2017/01/29/triumph_of_the_city.html" title="城市的胜利" rel="bookmark">城市的胜利</a>
  </li>
  
  <li>
  <a href="/%E8%AF%BB%E4%B9%A6/2017/01/29/history_and_geography.html" title="城市的胜利" rel="bookmark">城市的胜利</a>
  </li>
  
  <li>
  <a href="/%E4%B9%A6%E6%91%98/2016/07/23/elite's%20fail.html" title="精英的兴衰-书摘" rel="bookmark">精英的兴衰-书摘</a>
  </li>
  
  <li>
  <a href="/%E8%A1%8C%E4%B8%9A/2016/07/13/Benchmarking_netflix_dynomite.html" title="Netlix Dynomite性能基准测试，基于AWS和Redis" rel="bookmark">Netlix Dynomite性能基准测试，基于AWS和Redis</a>
  </li>
  
</div>


<div class="sidebar-module">
  <h4>分类目录</h4>
  
  <li><a href="/categories/#读书" title="读书" rel="37">读书 (37)</a></li>
  
  <li><a href="/categories/#行业" title="行业" rel="4">行业 (4)</a></li>
  
  <li><a href="/categories/#总结与遐想" title="总结与遐想" rel="10">总结与遐想 (10)</a></li>
  
  <li><a href="/categories/#编程" title="编程" rel="10">编程 (10)</a></li>
  
  <li><a href="/categories/#书摘" title="书摘" rel="4">书摘 (4)</a></li>
  
</div>


<div class="sidebar-module">
  <h4>存档</h4>

  
  
  
  
  
  <li id="2017" > <a href="/archives/#2017">2017</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2016" > <a href="/archives/#2016">2016</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2015" > <a href="/archives/#2015">2015</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2014" > <a href="/archives/#2014">2014</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2013" > <a href="/archives/#2013">2013</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2012" > <a href="/archives/#2012">2012</a></li>
  
  
  
  
  
  
  
  

</div>


</div>



  

  <footer class="site-footer">

  <p>Copyright &copy; <a href="/">学习笔记</a></p>
  <p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
  on 
  
  <a href="https://github.com/">Github</a>
  
  | Theme <a href="https://github.com/yulijia/freshman21/">Freshman21</a> Design by <a href="http://yulijia.net">Lijia Yu</a>  

</footer>


</div>

</body>

</html>
